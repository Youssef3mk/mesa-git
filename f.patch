From c26549f42faa9ecd06e760113d6112fb1017bf40 Mon Sep 17 00:00:00 2001
From: Mel Henning <drawoc@darkrefraction.com>
Date: Fri, 29 Nov 2024 16:09:16 -0500
Subject: [PATCH 1/2] nak: Relax memory ordering for global memory

---
 src/nouveau/compiler/nak/from_nir.rs | 13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)

diff --git a/src/nouveau/compiler/nak/from_nir.rs b/src/nouveau/compiler/nak/from_nir.rs
index 82cba7d42721a..a661b010287b2 100644
--- a/src/nouveau/compiler/nak/from_nir.rs
+++ b/src/nouveau/compiler/nak/from_nir.rs
@@ -3071,14 +3071,18 @@ impl<'a> ShaderFromNir<'a> {
                 let size_B =
                     (intrin.def.bit_size() / 8) * intrin.def.num_components();
                 assert!(u32::from(size_B) <= intrin.align());
+
                 let order = if intrin.intrinsic
                     == nir_intrinsic_load_global_constant
                     || (intrin.access() & ACCESS_CAN_REORDER) != 0
                 {
                     MemOrder::Constant
-                } else {
+                } else if intrin.access() & ACCESS_VOLATILE != 0 {
                     MemOrder::Strong(MemScope::GPU)
+                } else {
+                    MemOrder::Strong(MemScope::CTA)
                 };
+
                 let access = MemAccess {
                     mem_type: MemType::from_size(size_B, false),
                     space: MemSpace::Global(MemAddrType::A64),
@@ -3573,10 +3577,15 @@ impl<'a> ShaderFromNir<'a> {
                 let size_B =
                     (srcs[0].bit_size() / 8) * srcs[0].num_components();
                 assert!(u32::from(size_B) <= intrin.align());
+                let order = if intrin.access() & ACCESS_VOLATILE != 0 {
+                    MemOrder::Strong(MemScope::GPU)
+                } else {
+                    MemOrder::Strong(MemScope::CTA)
+                };
                 let access = MemAccess {
                     mem_type: MemType::from_size(size_B, false),
                     space: MemSpace::Global(MemAddrType::A64),
-                    order: MemOrder::Strong(MemScope::GPU),
+                    order,
                     eviction_priority: self
                         .get_eviction_priority(intrin.access()),
                 };
-- 
GitLab


From 5c091b2387e3758ed513338caaaf8def9c4182eb Mon Sep 17 00:00:00 2001
From: Mel Henning <drawoc@darkrefraction.com>
Date: Tue, 28 Jan 2025 23:20:04 -0500
Subject: [PATCH 2/2] nak: Relax memory ordering for surfaces

---
 src/nouveau/compiler/nak/from_nir.rs | 16 +++++++++++++---
 1 file changed, 13 insertions(+), 3 deletions(-)

diff --git a/src/nouveau/compiler/nak/from_nir.rs b/src/nouveau/compiler/nak/from_nir.rs
index a661b010287b2..9bc3a775968f4 100644
--- a/src/nouveau/compiler/nak/from_nir.rs
+++ b/src/nouveau/compiler/nak/from_nir.rs
@@ -2743,8 +2743,10 @@ impl<'a> ShaderFromNir<'a> {
 
                 let mem_order = if (intrin.access() & ACCESS_CAN_REORDER) != 0 {
                     MemOrder::Constant
-                } else {
+                } else if intrin.access() & ACCESS_VOLATILE != 0 {
                     MemOrder::Strong(MemScope::GPU)
+                } else {
+                    MemOrder::Strong(MemScope::CTA)
                 };
 
                 let comps = intrin.num_components;
@@ -2776,8 +2778,10 @@ impl<'a> ShaderFromNir<'a> {
 
                 let mem_order = if (intrin.access() & ACCESS_CAN_REORDER) != 0 {
                     MemOrder::Constant
-                } else {
+                } else if intrin.access() & ACCESS_VOLATILE != 0 {
                     MemOrder::Strong(MemScope::GPU)
+                } else {
+                    MemOrder::Strong(MemScope::CTA)
                 };
 
                 let comps = intrin.num_components;
@@ -2851,6 +2855,12 @@ impl<'a> ShaderFromNir<'a> {
                 // let sample = self.get_src(&srcs[2]);
                 let data = self.get_src(&srcs[3]);
 
+                let mem_order = if intrin.access() & ACCESS_VOLATILE != 0 {
+                    MemOrder::Strong(MemScope::GPU)
+                } else {
+                    MemOrder::Strong(MemScope::CTA)
+                };
+
                 let comps = intrin.num_components;
                 assert!(srcs[3].bit_size() == 32);
                 assert!(comps == 1 || comps == 2 || comps == 4);
@@ -2860,7 +2870,7 @@ impl<'a> ShaderFromNir<'a> {
                 b.push_op(OpSuSt {
                     image_access,
                     image_dim: dim,
-                    mem_order: MemOrder::Strong(MemScope::GPU),
+                    mem_order,
                     mem_eviction_priority: self
                         .get_eviction_priority(intrin.access()),
                     handle: handle,
-- 
GitLab

