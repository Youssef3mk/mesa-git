From cdc268a279f82501e6cdd73f4afbfacf227e0541 Mon Sep 17 00:00:00 2001
From: Mel Henning <mhenning@darkrefraction.com>
Date: Fri, 17 Oct 2025 19:08:37 -0400
Subject: [PATCH 1/3] vulkan: Add vk_union_dependency_info_src_stages

---
 src/nouveau/vulkan/nvk_event.c          | 11 ++++-------
 src/vulkan/runtime/vk_synchronization.c | 13 +++++++++++++
 src/vulkan/runtime/vk_synchronization.h |  4 ++++
 3 files changed, 21 insertions(+), 7 deletions(-)

diff --git a/src/nouveau/vulkan/nvk_event.c b/src/nouveau/vulkan/nvk_event.c
index 7e43bbdee3f49..0915284ad3020 100644
--- a/src/nouveau/vulkan/nvk_event.c
+++ b/src/nouveau/vulkan/nvk_event.c
@@ -9,6 +9,8 @@
 #include "nvk_entrypoints.h"
 #include "nvk_mme.h"
 
+#include "vk_synchronization.h"
+
 #include "nv_push_cl906f.h"
 #include "nv_push_cl9097.h"
 #include "nv_push_cl90b5.h"
@@ -214,13 +216,8 @@ nvk_CmdSetEvent2(VkCommandBuffer commandBuffer,
 
    nvk_cmd_flush_wait_dep(cmd, pDependencyInfo, false);
 
-   VkPipelineStageFlags2 stages = 0;
-   for (uint32_t i = 0; i < pDependencyInfo->memoryBarrierCount; i++)
-      stages |= pDependencyInfo->pMemoryBarriers[i].srcStageMask;
-   for (uint32_t i = 0; i < pDependencyInfo->bufferMemoryBarrierCount; i++)
-      stages |= pDependencyInfo->pBufferMemoryBarriers[i].srcStageMask;
-   for (uint32_t i = 0; i < pDependencyInfo->imageMemoryBarrierCount; i++)
-      stages |= pDependencyInfo->pImageMemoryBarriers[i].srcStageMask;
+   VkPipelineStageFlags2 stages =
+      vk_union_dependency_info_src_stages(pDependencyInfo);
 
    nvk_event_report_semaphore(cmd, stages, event->addr, VK_EVENT_SET);
 }
diff --git a/src/vulkan/runtime/vk_synchronization.c b/src/vulkan/runtime/vk_synchronization.c
index 092d9577efec5..f115715e0f1c7 100644
--- a/src/vulkan/runtime/vk_synchronization.c
+++ b/src/vulkan/runtime/vk_synchronization.c
@@ -89,6 +89,19 @@ vk_filter_dst_access_flags2(VkPipelineStageFlags2 stages,
           (all_read_access | VK_ACCESS_2_HOST_WRITE_BIT);
 }
 
+VkPipelineStageFlags2
+vk_union_dependency_info_src_stages(const VkDependencyInfo* pDependencyInfo)
+{
+   VkPipelineStageFlags2 stages = 0;
+   for (uint32_t i = 0; i < pDependencyInfo->memoryBarrierCount; i++)
+      stages |= pDependencyInfo->pMemoryBarriers[i].srcStageMask;
+   for (uint32_t i = 0; i < pDependencyInfo->bufferMemoryBarrierCount; i++)
+      stages |= pDependencyInfo->pBufferMemoryBarriers[i].srcStageMask;
+   for (uint32_t i = 0; i < pDependencyInfo->imageMemoryBarrierCount; i++)
+      stages |= pDependencyInfo->pImageMemoryBarriers[i].srcStageMask;
+   return stages;
+}
+
 VKAPI_ATTR void VKAPI_CALL
 vk_common_CmdWriteTimestamp(
    VkCommandBuffer                             commandBuffer,
diff --git a/src/vulkan/runtime/vk_synchronization.h b/src/vulkan/runtime/vk_synchronization.h
index c7ce69b7c54d1..cdef8885d5be3 100644
--- a/src/vulkan/runtime/vk_synchronization.h
+++ b/src/vulkan/runtime/vk_synchronization.h
@@ -85,6 +85,10 @@ VkAccessFlags2
 vk_filter_dst_access_flags2(VkPipelineStageFlags2 stages,
                             VkAccessFlags2 access);
 
+/** Union all the srcStageMasks on a VkDependencyInfo */
+VkPipelineStageFlags2
+vk_union_dependency_info_src_stages(const VkDependencyInfo* pDependencyInfo);
+
 #ifdef __cplusplus
 }
 #endif
-- 
GitLab


From e6ba0712257322c685532f2962efc64ce26db706 Mon Sep 17 00:00:00 2001
From: Mel Henning <mhenning@darkrefraction.com>
Date: Fri, 17 Oct 2025 19:45:02 -0400
Subject: [PATCH 2/3] vulkan: VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR

Before, just about every driver skipped implementing this (which is
incorrect), with the exception of panvk, which initially skipped
implementing it and then fixed this in 6d00e95b. Add a common
implementation of this in the vulkan runtime for drivers to use.

This is accomplished by adding a common implementation of vkCmdSetEvent2
and vkCmdWaitEvents2. Since these then need to call back into
driver-specific implementations, we add callbacks to vk_device which
are equivalent to the vulkan functions except without support for
ASYMMETRIC_EVENT_BIT.

Test with
dEQP-VK.synchronization2.op.single_queue.event.*_maintenance9
---
 src/vulkan/runtime/vk_device.h          |  11 ++
 src/vulkan/runtime/vk_synchronization.c | 170 ++++++++++++++++++++++++
 2 files changed, 181 insertions(+)

diff --git a/src/vulkan/runtime/vk_device.h b/src/vulkan/runtime/vk_device.h
index 8b45d0244d12a..63f4455dc8772 100644
--- a/src/vulkan/runtime/vk_device.h
+++ b/src/vulkan/runtime/vk_device.h
@@ -145,6 +145,17 @@ struct vk_device {
    /** Acceleration structure build vtable for common BVH building. */
    const struct vk_acceleration_structure_build_ops *as_build_ops;
 
+   /** vkCmdSetEvent2 without VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR support */
+   void (*cmd_set_event_symmetric)(VkCommandBuffer commandBuffer,
+                                   VkEvent event,
+                                   const VkDependencyInfo* pDependencyInfo);
+
+   /** vkCmdWaitEvents2 without VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR support */
+   void (*cmd_wait_events_symmetric)(VkCommandBuffer ommandBuffer,
+                                     uint32_t eventCount,
+                                     const VkEvent* pEvents,
+                                     const VkDependencyInfo* pDependencyInfos);
+
    /**
     * Write data to a buffer from the command processor. This is simpler than
     * setting up a staging buffer and faster for small writes, but is not
diff --git a/src/vulkan/runtime/vk_synchronization.c b/src/vulkan/runtime/vk_synchronization.c
index f115715e0f1c7..d77b5fb2dacc6 100644
--- a/src/vulkan/runtime/vk_synchronization.c
+++ b/src/vulkan/runtime/vk_synchronization.c
@@ -246,6 +246,176 @@ vk_common_CmdPipelineBarrier(
    STACK_ARRAY_FINISH(image_barriers);
 }
 
+VKAPI_ATTR void VKAPI_CALL
+vk_common_CmdSetEvent2(
+    VkCommandBuffer                             commandBuffer,
+    VkEvent                                     event,
+    const VkDependencyInfo*                     pDependencyInfo)
+{
+   VK_FROM_HANDLE(vk_command_buffer, cmd_buffer, commandBuffer);
+   struct vk_device *device = cmd_buffer->base.device;
+
+   bool asymmetric = pDependencyInfo->dependencyFlags &
+                     VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR;
+   if (!asymmetric) {
+      device->cmd_set_event_symmetric(commandBuffer, event, pDependencyInfo);
+      return;
+   }
+
+   /* VUID-vkCmdSetEvent2-dependencyFlags-10785, 10786, 10787 */
+   assert(pDependencyInfo->memoryBarrierCount == 1 &&
+          pDependencyInfo->bufferMemoryBarrierCount == 0 &&
+          pDependencyInfo->imageMemoryBarrierCount == 0);
+   VkPipelineStageFlags2 stageMask =
+      pDependencyInfo->pMemoryBarriers[0].srcStageMask;
+
+   VkMemoryBarrier2 mem_barrier = {
+      .sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2,
+      .srcStageMask = (VkPipelineStageFlags2) stageMask,
+      .dstStageMask = (VkPipelineStageFlags2) stageMask,
+   };
+   VkDependencyInfo dep_info = {
+      .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
+      .memoryBarrierCount = 1,
+      .pMemoryBarriers = &mem_barrier,
+   };
+
+   device->cmd_set_event_symmetric(commandBuffer, event, &dep_info);
+}
+
+VKAPI_ATTR void VKAPI_CALL
+vk_common_CmdWaitEvents2(
+    VkCommandBuffer                             commandBuffer,
+    uint32_t                                    eventCount,
+    const VkEvent*                              pEvents,
+    const VkDependencyInfo*                     pDependencyInfos)
+{
+   VK_FROM_HANDLE(vk_command_buffer, cmd_buffer, commandBuffer);
+   struct vk_device *device = cmd_buffer->base.device;
+
+   if (eventCount == 0)
+      return;
+
+   uint32_t asym_count = 0;
+   uint32_t asym_memory_barrier_count = 0;
+   uint32_t asym_buffer_memory_barrier_count = 0;
+   uint32_t asym_image_memory_barrier_count = 0;
+   for (uint32_t i = 0; i < eventCount; i++) {
+      if (pDependencyInfos[i].dependencyFlags &
+          VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR) {
+         asym_count += 1;
+         asym_memory_barrier_count +=
+            pDependencyInfos[i].memoryBarrierCount;
+         asym_buffer_memory_barrier_count +=
+            pDependencyInfos[i].bufferMemoryBarrierCount;
+         asym_image_memory_barrier_count +=
+            pDependencyInfos[i].imageMemoryBarrierCount;
+      }
+   }
+
+   if (asym_count == 0) {
+      device->cmd_wait_events_symmetric(commandBuffer, eventCount,
+                                        pEvents, pDependencyInfos);
+      return;
+   }
+
+   STACK_ARRAY(VkDependencyInfo, deps, eventCount);
+   STACK_ARRAY(VkMemoryBarrier2, stage_barrier, asym_count);
+
+   uint32_t asym_index = 0;
+   for (uint32_t i = 0; i < eventCount; i++) {
+      if (pDependencyInfos[i].dependencyFlags &
+          VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR) {
+         /* See VUID-vkCmdWaitEvents2-pEvents-10790 */
+         VkPipelineStageFlags2 srcStageMask =
+            vk_union_dependency_info_src_stages(pDependencyInfos);
+
+         /* Note that dstStageMask and srcStageMask in the
+          * cmd_wait_events_symmetric() call are the same.  This is to match
+          * the cmd_set_event_symmetric() call from vk_common_CmdSetEvent2().
+          * The actual src->dst stage barrier will happen as part of the
+          * CmdPipelineBarrier2() call below.
+          */
+         stage_barrier[asym_index] = (VkMemoryBarrier2) {
+            .sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2,
+            .srcStageMask = srcStageMask,
+            .dstStageMask = srcStageMask,
+         };
+
+         deps[i] = (VkDependencyInfo) {
+            .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
+            .memoryBarrierCount = 1,
+            .pMemoryBarriers = &stage_barrier[asym_index],
+         };
+
+         asym_index++;
+      } else {
+         deps[i] = pDependencyInfos[i];
+      }
+   }
+   device->cmd_wait_events_symmetric(commandBuffer, eventCount, pEvents, deps);
+
+   STACK_ARRAY_FINISH(deps);
+   STACK_ARRAY_FINISH(stage_barrier);
+
+   STACK_ARRAY(VkMemoryBarrier2, asym_memory_barrier,
+               asym_memory_barrier_count);
+   STACK_ARRAY(VkBufferMemoryBarrier2, asym_buffer_memory_barrier,
+               asym_buffer_memory_barrier_count);
+   STACK_ARRAY(VkImageMemoryBarrier2, asym_image_memory_barrier,
+               asym_image_memory_barrier_count);
+
+   uint32_t asym_memory_barrier_index = 0;
+   uint32_t asym_buffer_memory_barrier_index = 0;
+   uint32_t asym_image_memory_barrier_index = 0;
+
+   for (uint32_t i = 0; i < eventCount; i++) {
+      if (pDependencyInfos[i].dependencyFlags &
+          VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR) {
+         const VkDependencyInfo* pDependencyInfo = &pDependencyInfos[i];
+         for (uint32_t j = 0; j < pDependencyInfo->memoryBarrierCount; j++)
+            asym_memory_barrier[asym_memory_barrier_index++] =
+               pDependencyInfo->pMemoryBarriers[j];
+         for (uint32_t j = 0; j < pDependencyInfo->bufferMemoryBarrierCount; j++)
+            asym_buffer_memory_barrier[asym_buffer_memory_barrier_index++] =
+               pDependencyInfo->pBufferMemoryBarriers[j];
+         for (uint32_t j = 0; j < pDependencyInfo->imageMemoryBarrierCount; j++)
+            asym_image_memory_barrier[asym_image_memory_barrier_index++] =
+               pDependencyInfo->pImageMemoryBarriers[j];
+      }
+   }
+
+   /* Setting dependency to 0 because :
+    *
+    *    - For BY_REGION_BIT and VIEW_LOCAL_BIT, events are not allowed inside a
+    *      render pass so these don't apply.
+    *
+    *    - For DEVICE_GROUP_BIT, we have the following bit of spec text:
+    *
+    *        "Semaphore and event dependencies are device-local and only
+    *         execute on the one physical device that performs the
+    *         dependency."
+    */
+   const VkDependencyFlags dep_flags = 0;
+
+   VkDependencyInfo pipeline_dep = {
+      .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
+      .dependencyFlags = dep_flags,
+      .memoryBarrierCount = asym_memory_barrier_count,
+      .pMemoryBarriers = asym_memory_barrier,
+      .bufferMemoryBarrierCount = asym_buffer_memory_barrier_count,
+      .pBufferMemoryBarriers = asym_buffer_memory_barrier,
+      .imageMemoryBarrierCount = asym_image_memory_barrier_count,
+      .pImageMemoryBarriers = asym_image_memory_barrier,
+   };
+
+   device->dispatch_table.CmdPipelineBarrier2(commandBuffer, &pipeline_dep);
+
+   STACK_ARRAY_FINISH(asym_memory_barrier);
+   STACK_ARRAY_FINISH(asym_buffer_memory_barrier);
+   STACK_ARRAY_FINISH(asym_image_memory_barrier);
+}
+
 VKAPI_ATTR void VKAPI_CALL
 vk_common_CmdSetEvent(
     VkCommandBuffer                             commandBuffer,
-- 
GitLab


From 5e734d045f9e2af3e9aad90a8eab21a42cac2af7 Mon Sep 17 00:00:00 2001
From: Mel Henning <mhenning@darkrefraction.com>
Date: Fri, 17 Oct 2025 19:54:16 -0400
Subject: [PATCH 3/3] nvk: Use the runtime ASYMMETRIC_EVENT_BIT impl

Fixes the test
dEQP-VK.synchronization2.op.single_queue.event.write_ssbo_compute_read_ssbo_compute.buffer_16384_maintenance9
Fixes: 7692d3c0e1a2 ("nvk: Advertise VK_KHR_maintenance9")
---
 src/nouveau/vulkan/nvk_device.c |  3 +++
 src/nouveau/vulkan/nvk_event.c  | 18 +++++++++---------
 src/nouveau/vulkan/nvk_event.h  | 11 +++++++++++
 3 files changed, 23 insertions(+), 9 deletions(-)

diff --git a/src/nouveau/vulkan/nvk_device.c b/src/nouveau/vulkan/nvk_device.c
index ae8ecff33d6ab..fc37e7e137dbd 100644
--- a/src/nouveau/vulkan/nvk_device.c
+++ b/src/nouveau/vulkan/nvk_device.c
@@ -6,6 +6,7 @@
 
 #include "nvk_cmd_buffer.h"
 #include "nvk_entrypoints.h"
+#include "nvk_event.h"
 #include "nvk_instance.h"
 #include "nvk_physical_device.h"
 #include "nvk_sampler.h"
@@ -156,6 +157,8 @@ nvk_CreateDevice(VkPhysicalDevice physicalDevice,
       goto fail_alloc;
 
    dev->vk.shader_ops = &nvk_device_shader_ops;
+   dev->vk.cmd_set_event_symmetric = nvk_cmd_set_event_symmetric;
+   dev->vk.cmd_wait_events_symmetric = nvk_cmd_wait_events_symmetric;
 
    uint32_t queue_count = 0;
    for (uint32_t i = 0; i < pCreateInfo->queueCreateInfoCount; i++)
diff --git a/src/nouveau/vulkan/nvk_event.c b/src/nouveau/vulkan/nvk_event.c
index 0915284ad3020..0a53d8b3f97b1 100644
--- a/src/nouveau/vulkan/nvk_event.c
+++ b/src/nouveau/vulkan/nvk_event.c
@@ -206,10 +206,10 @@ nvk_event_report_semaphore(struct nvk_cmd_buffer *cmd,
    }
 }
 
-VKAPI_ATTR void VKAPI_CALL
-nvk_CmdSetEvent2(VkCommandBuffer commandBuffer,
-                 VkEvent _event,
-                 const VkDependencyInfo *pDependencyInfo)
+void
+nvk_cmd_set_event_symmetric(VkCommandBuffer commandBuffer,
+                            VkEvent _event,
+                            const VkDependencyInfo *pDependencyInfo)
 {
    VK_FROM_HANDLE(nvk_cmd_buffer, cmd, commandBuffer);
    VK_FROM_HANDLE(nvk_event, event, _event);
@@ -233,11 +233,11 @@ nvk_CmdResetEvent2(VkCommandBuffer commandBuffer,
    nvk_event_report_semaphore(cmd, stageMask, event->addr, VK_EVENT_RESET);
 }
 
-VKAPI_ATTR void VKAPI_CALL
-nvk_CmdWaitEvents2(VkCommandBuffer commandBuffer,
-                   uint32_t eventCount,
-                   const VkEvent *pEvents,
-                   const VkDependencyInfo *pDependencyInfos)
+void
+nvk_cmd_wait_events_symmetric(VkCommandBuffer commandBuffer,
+                              uint32_t eventCount,
+                              const VkEvent *pEvents,
+                              const VkDependencyInfo *pDependencyInfos)
 {
    VK_FROM_HANDLE(nvk_cmd_buffer, cmd, commandBuffer);
 
diff --git a/src/nouveau/vulkan/nvk_event.h b/src/nouveau/vulkan/nvk_event.h
index 25f668aae95fd..d56c50a4903d0 100644
--- a/src/nouveau/vulkan/nvk_event.h
+++ b/src/nouveau/vulkan/nvk_event.h
@@ -21,4 +21,15 @@ VK_DEFINE_NONDISP_HANDLE_CASTS(nvk_event, base, VkEvent, VK_OBJECT_TYPE_EVENT)
 uint32_t
 vk_stage_flags_to_nv9097_pipeline_location(VkPipelineStageFlags2 flags);
 
+void
+nvk_cmd_set_event_symmetric(VkCommandBuffer commandBuffer,
+                            VkEvent _event,
+                            const VkDependencyInfo *pDependencyInfo);
+
+void
+nvk_cmd_wait_events_symmetric(VkCommandBuffer commandBuffer,
+                              uint32_t eventCount,
+                              const VkEvent *pEvents,
+                              const VkDependencyInfo *pDependencyInfos);
+
 #endif /* define NVK_EVENT_H */
-- 
GitLab

