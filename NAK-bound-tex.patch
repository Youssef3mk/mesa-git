diff --git a/src/nouveau/compiler/nak/from_nir.rs b/src/nouveau/compiler/nak/from_nir.rs
index d74eadd05aac99b2e95c4be4393ca6b782b71b5b..2cfa959b865a950cb6feba74c09493bbb26557f9 100644
--- a/src/nouveau/compiler/nak/from_nir.rs
+++ b/src/nouveau/compiler/nak/from_nir.rs
@@ -1745,6 +1745,20 @@ impl<'a> ShaderFromNir<'a> {
         let flags: nak_nir_tex_flags =
             unsafe { std::mem::transmute_copy(&tex.backend_flags) };
 
+        let tex_ref = match flags.ref_type() {
+            NAK_NIR_TEX_REF_TYPE_BOUND => {
+                TexRef::Bound(tex.texture_index.try_into().unwrap())
+            }
+            NAK_NIR_TEX_REF_TYPE_CBUF => {
+                TexRef::CBuf(TexCBufRef {
+                    idx: (tex.texture_index >> 16).try_into().unwrap(),
+                    offset: tex.texture_index as u16,
+                })
+            }
+            NAK_NIR_TEX_REF_TYPE_BINDLESS => TexRef::Bindless,
+            _ => panic!("Invalid tex ref type"),
+        };
+
         let mask = tex.def.components_read();
         let mut mask = u8::try_from(mask).unwrap();
         if flags.is_sparse() {
@@ -1774,6 +1788,7 @@ impl<'a> ShaderFromNir<'a> {
             assert!(fault.is_none());
             b.push_op(OpTxq {
                 dsts: dsts,
+                tex: tex_ref,
                 src: src,
                 query: TexQuery::Dimension,
                 mask: mask,
@@ -1783,6 +1798,7 @@ impl<'a> ShaderFromNir<'a> {
             assert!(fault.is_none());
             b.push_op(OpTxq {
                 dsts: dsts,
+                tex: tex_ref,
                 src: src,
                 query: TexQuery::TextureType,
                 mask: mask,
@@ -1814,6 +1830,7 @@ impl<'a> ShaderFromNir<'a> {
                 b.push_op(OpTxd {
                     dsts: dsts,
                     fault,
+                    tex: tex_ref,
                     srcs: srcs,
                     dim: dim,
                     offset: offset_mode == Tld4OffsetMode::AddOffI,
@@ -1823,6 +1840,7 @@ impl<'a> ShaderFromNir<'a> {
                 assert!(offset_mode == Tld4OffsetMode::None);
                 b.push_op(OpTmml {
                     dsts: dsts,
+                    tex: tex_ref,
                     srcs: srcs,
                     dim: dim,
                     mask: mask,
@@ -1832,6 +1850,7 @@ impl<'a> ShaderFromNir<'a> {
                 b.push_op(OpTld {
                     dsts: dsts,
                     fault,
+                    tex: tex_ref,
                     srcs: srcs,
                     dim: dim,
                     lod_mode: lod_mode,
@@ -1843,6 +1862,7 @@ impl<'a> ShaderFromNir<'a> {
                 b.push_op(OpTld4 {
                     dsts: dsts,
                     fault,
+                    tex: tex_ref,
                     srcs: srcs,
                     dim: dim,
                     comp: tex.component().try_into().unwrap(),
@@ -1855,6 +1875,7 @@ impl<'a> ShaderFromNir<'a> {
                 b.push_op(OpTex {
                     dsts: dsts,
                     fault,
+                    tex: tex_ref,
                     srcs: srcs,
                     dim: dim,
                     lod_mode: lod_mode,
diff --git a/src/nouveau/compiler/nak/ir.rs b/src/nouveau/compiler/nak/ir.rs
index b13a9bd867e007a59e8630bb28435a6d7194230b..d6cecac97837d19d2953bf61c5c221572bf28116 100644
--- a/src/nouveau/compiler/nak/ir.rs
+++ b/src/nouveau/compiler/nak/ir.rs
@@ -2034,6 +2034,32 @@ impl fmt::Display for FRndMode {
     }
 }
 
+#[derive(Clone, Copy, Eq, PartialEq)]
+pub struct TexCBufRef {
+    pub idx: u8,
+    pub offset: u16,
+}
+
+#[allow(dead_code)]
+#[derive(Clone, Copy, Eq, PartialEq)]
+pub enum TexRef {
+    Bound(u16),
+    CBuf(TexCBufRef),
+    Bindless,
+}
+
+impl fmt::Display for TexRef {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        match self {
+            TexRef::Bound(idx) => write!(f, "tex[{idx}]"),
+            TexRef::CBuf(TexCBufRef { idx, offset }) => {
+                write!(f, "c[{idx:#x}][{offset:#x}]")
+            }
+            TexRef::Bindless => write!(f, "bindless"),
+        }
+    }
+}
+
 #[derive(Clone, Copy, Eq, PartialEq)]
 pub enum TexDim {
     _1D,
@@ -4636,6 +4662,8 @@ pub struct OpTex {
     pub dsts: [Dst; 2],
     pub fault: Dst,
 
+    pub tex: TexRef,
+
     #[src_type(SSA)]
     pub srcs: [Src; 2],
 
@@ -4648,7 +4676,7 @@ pub struct OpTex {
 
 impl DisplayOp for OpTex {
     fn fmt_op(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        write!(f, "tex.b{}", self.dim)?;
+        write!(f, "tex{}", self.dim)?;
         if self.lod_mode != TexLodMode::Auto {
             write!(f, ".{}", self.lod_mode)?;
         }
@@ -4658,7 +4686,7 @@ impl DisplayOp for OpTex {
         if self.z_cmpr {
             write!(f, ".dc")?;
         }
-        write!(f, " {} {}", self.srcs[0], self.srcs[1])
+        write!(f, " {} {} {}", self.tex, self.srcs[0], self.srcs[1])
     }
 }
 impl_display_for_op!(OpTex);
@@ -4669,6 +4697,8 @@ pub struct OpTld {
     pub dsts: [Dst; 2],
     pub fault: Dst,
 
+    pub tex: TexRef,
+
     #[src_type(SSA)]
     pub srcs: [Src; 2],
 
@@ -4681,7 +4711,7 @@ pub struct OpTld {
 
 impl DisplayOp for OpTld {
     fn fmt_op(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        write!(f, "tld.b{}", self.dim)?;
+        write!(f, "tld{}", self.dim)?;
         if self.lod_mode != TexLodMode::Auto {
             write!(f, ".{}", self.lod_mode)?;
         }
@@ -4691,7 +4721,7 @@ impl DisplayOp for OpTld {
         if self.is_ms {
             write!(f, ".ms")?;
         }
-        write!(f, " {} {}", self.srcs[0], self.srcs[1])
+        write!(f, " {} {} {}", self.tex, self.srcs[0], self.srcs[1])
     }
 }
 impl_display_for_op!(OpTld);
@@ -4702,6 +4732,8 @@ pub struct OpTld4 {
     pub dsts: [Dst; 2],
     pub fault: Dst,
 
+    pub tex: TexRef,
+
     #[src_type(SSA)]
     pub srcs: [Src; 2],
 
@@ -4714,11 +4746,11 @@ pub struct OpTld4 {
 
 impl DisplayOp for OpTld4 {
     fn fmt_op(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        write!(f, "tld4.g.b{}", self.dim)?;
+        write!(f, "tld4.g{}", self.dim)?;
         if self.offset_mode != Tld4OffsetMode::None {
             write!(f, ".{}", self.offset_mode)?;
         }
-        write!(f, " {} {}", self.srcs[0], self.srcs[1])
+        write!(f, " {} {} {}", self.tex, self.srcs[0], self.srcs[1])
     }
 }
 impl_display_for_op!(OpTld4);
@@ -4728,6 +4760,8 @@ impl_display_for_op!(OpTld4);
 pub struct OpTmml {
     pub dsts: [Dst; 2],
 
+    pub tex: TexRef,
+
     #[src_type(SSA)]
     pub srcs: [Src; 2],
 
@@ -4739,8 +4773,8 @@ impl DisplayOp for OpTmml {
     fn fmt_op(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
         write!(
             f,
-            "tmml.b.lod{} {} {}",
-            self.dim, self.srcs[0], self.srcs[1]
+            "tmml.lod{} {} {} {}",
+            self.dim, self.tex, self.srcs[0], self.srcs[1]
         )
     }
 }
@@ -4752,6 +4786,8 @@ pub struct OpTxd {
     pub dsts: [Dst; 2],
     pub fault: Dst,
 
+    pub tex: TexRef,
+
     #[src_type(SSA)]
     pub srcs: [Src; 2],
 
@@ -4762,11 +4798,11 @@ pub struct OpTxd {
 
 impl DisplayOp for OpTxd {
     fn fmt_op(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        write!(f, "txd.b{}", self.dim)?;
+        write!(f, "txd{}", self.dim)?;
         if self.offset {
             write!(f, ".aoffi")?;
         }
-        write!(f, " {} {}", self.srcs[0], self.srcs[1])
+        write!(f, " {} {} {}", self.tex, self.srcs[0], self.srcs[1])
     }
 }
 impl_display_for_op!(OpTxd);
@@ -4776,6 +4812,8 @@ impl_display_for_op!(OpTxd);
 pub struct OpTxq {
     pub dsts: [Dst; 2],
 
+    pub tex: TexRef,
+
     #[src_type(SSA)]
     pub src: Src,
 
@@ -4785,7 +4823,7 @@ pub struct OpTxq {
 
 impl DisplayOp for OpTxq {
     fn fmt_op(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        write!(f, "txq.b {} {}", self.src, self.query)
+        write!(f, "txq {} {} {}", self.tex, self.src, self.query)
     }
 }
 impl_display_for_op!(OpTxq);
diff --git a/src/nouveau/compiler/nak/sm50.rs b/src/nouveau/compiler/nak/sm50.rs
index 684d5f565e65d3fe79d9502e5ff95fb0bae621b0..d81a71c6175d8336fa27445f7e0c0e22d477edeb 100644
--- a/src/nouveau/compiler/nak/sm50.rs
+++ b/src/nouveau/compiler/nak/sm50.rs
@@ -2050,7 +2050,22 @@ impl SM50Op for OpTex {
     }
 
     fn encode(&self, e: &mut SM50Encoder<'_>) {
-        e.set_opcode(0xdeb8);
+        match self.tex {
+            TexRef::Bound(idx) => {
+                e.set_opcode(0x0380);
+                e.set_field(36..49, idx);
+                e.set_bit(54, self.offset);
+                e.set_tex_lod_mode(55..57, self.lod_mode);
+            }
+            TexRef::CBuf { .. } => {
+                panic!("SM50 doesn't have CBuf textures");
+            }
+            TexRef::Bindless => {
+                e.set_opcode(0xdeb8);
+                e.set_bit(36, self.offset);
+                e.set_tex_lod_mode(37..39, self.lod_mode);
+            }
+        }
 
         e.set_dst(self.dsts[0]);
         assert!(self.dsts[1].is_none());
@@ -2061,8 +2076,6 @@ impl SM50Op for OpTex {
         e.set_tex_dim(28..31, self.dim);
         e.set_field(31..35, self.mask);
         e.set_bit(35, false); // ToDo: NDV
-        e.set_bit(36, self.offset);
-        e.set_tex_lod_mode(37..39, self.lod_mode);
         e.set_bit(49, false); // TODO: .NODEP
         e.set_bit(50, self.z_cmpr);
     }
@@ -2074,7 +2087,18 @@ impl SM50Op for OpTld {
     }
 
     fn encode(&self, e: &mut SM50Encoder<'_>) {
-        e.set_opcode(0xdd38);
+        match self.tex {
+            TexRef::Bound(idx) => {
+                e.set_opcode(0xdc38);
+                e.set_field(36..49, idx);
+            }
+            TexRef::CBuf { .. } => {
+                panic!("SM50 doesn't have CBuf textures");
+            }
+            TexRef::Bindless => {
+                e.set_opcode(0xdd38);
+            }
+        }
 
         e.set_dst(self.dsts[0]);
         assert!(self.dsts[1].is_none());
@@ -2102,7 +2126,27 @@ impl SM50Op for OpTld4 {
     }
 
     fn encode(&self, e: &mut SM50Encoder<'_>) {
-        e.set_opcode(0xdef8);
+        let offset_mode = match self.offset_mode {
+            Tld4OffsetMode::None => 0_u8,
+            Tld4OffsetMode::AddOffI => 1_u8,
+            Tld4OffsetMode::PerPx => 2_u8,
+        };
+        match self.tex {
+            TexRef::Bound(idx) => {
+                e.set_opcode(0xc838);
+                e.set_field(36..49, idx);
+                e.set_field(54..56, offset_mode);
+                e.set_field(56..58, self.comp);
+            }
+            TexRef::CBuf { .. } => {
+                panic!("SM50 doesn't have CBuf textures");
+            }
+            TexRef::Bindless => {
+                e.set_opcode(0xdef8);
+                e.set_field(36..38, offset_mode);
+                e.set_field(38..40, self.comp);
+            }
+        }
 
         e.set_dst(self.dsts[0]);
         assert!(self.dsts[1].is_none());
@@ -2113,15 +2157,6 @@ impl SM50Op for OpTld4 {
         e.set_tex_dim(28..31, self.dim);
         e.set_field(31..35, self.mask);
         e.set_bit(35, false); // ToDo: NDV
-        e.set_field(
-            36..38,
-            match self.offset_mode {
-                Tld4OffsetMode::None => 0_u8,
-                Tld4OffsetMode::AddOffI => 1_u8,
-                Tld4OffsetMode::PerPx => 2_u8,
-            },
-        );
-        e.set_field(38..40, self.comp);
         e.set_bit(49, false); // TODO: .NODEP
         e.set_bit(50, self.z_cmpr);
     }
@@ -2133,7 +2168,18 @@ impl SM50Op for OpTmml {
     }
 
     fn encode(&self, e: &mut SM50Encoder<'_>) {
-        e.set_opcode(0xdf60);
+        match self.tex {
+            TexRef::Bound(idx) => {
+                e.set_opcode(0xdf58);
+                e.set_field(36..49, idx);
+            }
+            TexRef::CBuf { .. } => {
+                panic!("SM50 doesn't have CBuf textures");
+            }
+            TexRef::Bindless => {
+                e.set_opcode(0xdf60);
+            }
+        }
 
         e.set_dst(self.dsts[0]);
         assert!(self.dsts[1].is_none());
@@ -2153,7 +2199,18 @@ impl SM50Op for OpTxd {
     }
 
     fn encode(&self, e: &mut SM50Encoder<'_>) {
-        e.set_opcode(0xde78);
+        match self.tex {
+            TexRef::Bound(idx) => {
+                e.set_opcode(0xde38);
+                e.set_field(36..49, idx);
+            }
+            TexRef::CBuf { .. } => {
+                panic!("SM50 doesn't have CBuf textures");
+            }
+            TexRef::Bindless => {
+                e.set_opcode(0xde78);
+            }
+        }
 
         e.set_dst(self.dsts[0]);
         assert!(self.dsts[1].is_none());
@@ -2174,7 +2231,18 @@ impl SM50Op for OpTxq {
     }
 
     fn encode(&self, e: &mut SM50Encoder<'_>) {
-        e.set_opcode(0xdf50);
+        match self.tex {
+            TexRef::Bound(idx) => {
+                e.set_opcode(0xdf48);
+                e.set_field(36..49, idx);
+            }
+            TexRef::CBuf { .. } => {
+                panic!("SM50 doesn't have CBuf textures");
+            }
+            TexRef::Bindless => {
+                e.set_opcode(0xdf50);
+            }
+        }
 
         e.set_dst(self.dsts[0]);
         assert!(self.dsts[1].is_none());
diff --git a/src/nouveau/compiler/nak/sm70.rs b/src/nouveau/compiler/nak/sm70.rs
index e1a8d788ba0763e462350f008a503e1373425c8b..3b12d9c7916772a05f21ef71629cfdf0d65c5656 100644
--- a/src/nouveau/compiler/nak/sm70.rs
+++ b/src/nouveau/compiler/nak/sm70.rs
@@ -2265,6 +2265,14 @@ impl SM70Op for OpR2UR {
 }
 
 impl SM70Encoder<'_> {
+    fn set_tex_cb_ref(&mut self, range: Range<usize>, cb: TexCBufRef) {
+        assert!(range.len() == 19);
+        let mut v = BitMutView::new_subset(self, range);
+        assert!(cb.offset % 4 == 0);
+        v.set_field(0..14, cb.offset / 4);
+        v.set_field(14..19, cb.idx);
+    }
+
     fn set_tex_dim(&mut self, range: Range<usize>, dim: TexDim) {
         assert!(range.len() == 3);
         self.set_field(
@@ -2318,8 +2326,19 @@ impl SM70Op for OpTex {
     }
 
     fn encode(&self, e: &mut SM70Encoder<'_>) {
-        e.set_opcode(0x361);
-        e.set_bit(59, true); // .B
+        match self.tex {
+            TexRef::Bound(_) => {
+                panic!("SM70+ doesn't have legacy bound textures");
+            }
+            TexRef::CBuf(cb) => {
+                e.set_opcode(0xb60);
+                e.set_tex_cb_ref(40..59, cb);
+            }
+            TexRef::Bindless => {
+                e.set_opcode(0x361);
+                e.set_bit(59, true); // .B
+            }
+        }
 
         e.set_dst(self.dsts[0]);
         if let Dst::Reg(reg) = self.dsts[1] {
@@ -2349,8 +2368,19 @@ impl SM70Op for OpTld {
     }
 
     fn encode(&self, e: &mut SM70Encoder<'_>) {
-        e.set_opcode(0x367);
-        e.set_bit(59, true); // .B
+        match self.tex {
+            TexRef::Bound(_) => {
+                panic!("SM70+ doesn't have legacy bound textures");
+            }
+            TexRef::CBuf(cb) => {
+                e.set_opcode(0xb66);
+                e.set_tex_cb_ref(40..59, cb);
+            }
+            TexRef::Bindless => {
+                e.set_opcode(0x367);
+                e.set_bit(59, true); // .B
+            }
+        }
 
         e.set_dst(self.dsts[0]);
         if let Dst::Reg(reg) = self.dsts[1] {
@@ -2384,8 +2414,19 @@ impl SM70Op for OpTld4 {
     }
 
     fn encode(&self, e: &mut SM70Encoder<'_>) {
-        e.set_opcode(0x364);
-        e.set_bit(59, true); // .B
+        match self.tex {
+            TexRef::Bound(_) => {
+                panic!("SM70+ doesn't have legacy bound textures");
+            }
+            TexRef::CBuf(cb) => {
+                e.set_opcode(0xb63);
+                e.set_tex_cb_ref(40..59, cb);
+            }
+            TexRef::Bindless => {
+                e.set_opcode(0x364);
+                e.set_bit(59, true); // .B
+            }
+        }
 
         e.set_dst(self.dsts[0]);
         if let Dst::Reg(reg) = self.dsts[1] {
@@ -2422,8 +2463,19 @@ impl SM70Op for OpTmml {
     }
 
     fn encode(&self, e: &mut SM70Encoder<'_>) {
-        e.set_opcode(0x36a);
-        e.set_bit(59, true); // .B
+        match self.tex {
+            TexRef::Bound(_) => {
+                panic!("SM70+ doesn't have legacy bound textures");
+            }
+            TexRef::CBuf(cb) => {
+                e.set_opcode(0xb69);
+                e.set_tex_cb_ref(40..59, cb);
+            }
+            TexRef::Bindless => {
+                e.set_opcode(0x36a);
+                e.set_bit(59, true); // .B
+            }
+        }
 
         e.set_dst(self.dsts[0]);
         if let Dst::Reg(reg) = self.dsts[1] {
@@ -2448,8 +2500,19 @@ impl SM70Op for OpTxd {
     }
 
     fn encode(&self, e: &mut SM70Encoder<'_>) {
-        e.set_opcode(0x36d);
-        e.set_bit(59, true); // .B
+        match self.tex {
+            TexRef::Bound(_) => {
+                panic!("SM70+ doesn't have legacy bound textures");
+            }
+            TexRef::CBuf(cb) => {
+                e.set_opcode(0xb6c);
+                e.set_tex_cb_ref(40..59, cb);
+            }
+            TexRef::Bindless => {
+                e.set_opcode(0x36d);
+                e.set_bit(59, true); // .B
+            }
+        }
 
         e.set_dst(self.dsts[0]);
         if let Dst::Reg(reg) = self.dsts[1] {
@@ -2476,8 +2539,19 @@ impl SM70Op for OpTxq {
     }
 
     fn encode(&self, e: &mut SM70Encoder<'_>) {
-        e.set_opcode(0x370);
-        e.set_bit(59, true); // .B
+        match self.tex {
+            TexRef::Bound(_) => {
+                panic!("SM70+ doesn't have legacy bound textures");
+            }
+            TexRef::CBuf(cb) => {
+                e.set_opcode(0xb6f);
+                e.set_tex_cb_ref(40..59, cb);
+            }
+            TexRef::Bindless => {
+                e.set_opcode(0x370);
+                e.set_bit(59, true); // .B
+            }
+        }
 
         e.set_dst(self.dsts[0]);
         if let Dst::Reg(reg) = self.dsts[1] {
diff --git a/src/nouveau/compiler/nak_nir_lower_tex.c b/src/nouveau/compiler/nak_nir_lower_tex.c
index 2e16c26cda8204800d0df1900cbbb28eeb80c025..f23b28c545ff0280d47c43de1c21dfad77093706 100644
--- a/src/nouveau/compiler/nak_nir_lower_tex.c
+++ b/src/nouveau/compiler/nak_nir_lower_tex.c
@@ -9,6 +9,27 @@
 
 #include "util/u_math.h"
 
+static bool
+tex_handle_as_bindless(nir_def *tex_h, uint32_t *cbuf_out)
+{
+   if (tex_h->parent_instr->type != nir_instr_type_intrinsic)
+      return false;
+
+   nir_intrinsic_instr *intrin = nir_instr_as_intrinsic(tex_h->parent_instr);
+   if (intrin->intrinsic != nir_intrinsic_load_ubo)
+      return false;
+
+   if (!nir_src_is_const(intrin->src[1]))
+      return false;
+
+   uint32_t idx = nir_src_as_uint(intrin->src[0]);
+   uint32_t offset = nir_src_as_uint(intrin->src[1]);
+   assert(idx < (1 << 5) && offset < (1 << 16));
+   *cbuf_out = (idx << 16) | offset;
+
+   return true;
+}
+
 static enum glsl_sampler_dim
 remap_sampler_dim(enum glsl_sampler_dim dim)
 {
@@ -50,7 +71,12 @@ lower_tex(nir_builder *b, nir_tex_instr *tex, const struct nak_compiler *nak)
       tex_h = nir_ior(b, nir_iand_imm(b, tex_h,  0x000fffff),
                          nir_iand_imm(b, samp_h, 0xfff00000));
    }
-   tex_h = nir_u2u32(b, tex_h);
+
+   enum nak_nir_tex_ref_type ref_type = NAK_NIR_TEX_REF_TYPE_BINDLESS;
+   if (nak->sm >= 70 && tex_handle_as_bindless(tex_h, &tex->texture_index)) {
+      ref_type = NAK_NIR_TEX_REF_TYPE_CBUF;
+      tex_h = NULL; // nir_imm_int(b, 0);
+   }
 
    /* Array index is treated separately, so pull it off if we have one. */
    nir_def *arr_idx = NULL;
@@ -150,7 +176,8 @@ lower_tex(nir_builder *b, nir_tex_instr *tex, const struct nak_compiler *nak)
 
    if (nak->sm >= 50) {
       if (tex->op == nir_texop_txd) {
-         PUSH(src0, tex_h);
+         if (tex_h != NULL)
+            PUSH(src0, tex_h);
 
          for (uint32_t i = 0; i < coord_components; i++)
             PUSH(src0, nir_channel(b, coord, i));
@@ -182,7 +209,8 @@ lower_tex(nir_builder *b, nir_tex_instr *tex, const struct nak_compiler *nak)
          for (uint32_t i = 0; i < coord_components; i++)
             PUSH(src0, nir_channel(b, coord, i));
 
-         PUSH(src1, tex_h);
+         if (tex_h != NULL)
+            PUSH(src1, tex_h);
          if (ms_idx != NULL)
             PUSH(src1, ms_idx);
          if (lod != NULL)
@@ -200,6 +228,9 @@ lower_tex(nir_builder *b, nir_tex_instr *tex, const struct nak_compiler *nak)
       unreachable("Unsupported shader model");
    }
 
+   if (src1_comps == 0)
+      PUSH(src1, nir_imm_int(b, 0));
+
    nir_def *vec_srcs[2] = {
       nir_vec(b, src0, src0_comps),
       nir_vec(b, src1, src1_comps),
@@ -218,6 +249,7 @@ lower_tex(nir_builder *b, nir_tex_instr *tex, const struct nak_compiler *nak)
    tex->sampler_dim = remap_sampler_dim(tex->sampler_dim);
 
    struct nak_nir_tex_flags flags = {
+      .ref_type = ref_type,
       .lod_mode = lod_mode,
       .offset_mode = offset_mode,
       .has_z_cmpr = tex->is_shadow,
@@ -271,8 +303,11 @@ lower_txq(nir_builder *b, nir_tex_instr *tex, const struct nak_compiler *nak)
       }
    }
 
-   /* TODO: We should only support 32-bit handles */
-   tex_h = nir_u2u32(b, tex_h);
+   enum nak_nir_tex_ref_type ref_type = NAK_NIR_TEX_REF_TYPE_BINDLESS;
+   if (nak->sm >= 70 && tex_handle_as_bindless(tex_h, &tex->texture_index)) {
+      ref_type = NAK_NIR_TEX_REF_TYPE_CBUF;
+      tex_h = NULL;
+   }
 
    nir_def *txq_src;
    nir_component_mask_t mask;
@@ -281,17 +316,18 @@ lower_txq(nir_builder *b, nir_tex_instr *tex, const struct nak_compiler *nak)
       tex->op = nir_texop_hdr_dim_nv;
       if (lod == NULL)
          lod = nir_imm_int(b, 0);
-      txq_src = nir_vec2(b, tex_h, lod);
+      txq_src = tex_h != NULL ? nir_vec2(b, tex_h, lod) : lod;
       mask = BITSET_MASK(tex->def.num_components);
       break;
    case nir_texop_query_levels:
       tex->op = nir_texop_hdr_dim_nv;
-      txq_src = nir_vec2(b, tex_h, nir_imm_int(b, 0));
+      lod = nir_imm_int(b, 0);
+      txq_src = tex_h != NULL ? nir_vec2(b, tex_h, lod) : lod;
       mask = BITSET_BIT(3);
       break;
    case nir_texop_texture_samples:
       tex->op = nir_texop_tex_type_nv;
-      txq_src = tex_h;
+      txq_src = tex_h != NULL ? tex_h : nir_imm_int(b, 0);
       mask = BITSET_BIT(2);
       break;
    default:
@@ -307,6 +343,12 @@ lower_txq(nir_builder *b, nir_tex_instr *tex, const struct nak_compiler *nak)
 
    tex->sampler_dim = remap_sampler_dim(tex->sampler_dim);
 
+   struct nak_nir_tex_flags flags = {
+      .ref_type = ref_type,
+   };
+   STATIC_ASSERT(sizeof(flags) == sizeof(tex->backend_flags));
+   memcpy(&tex->backend_flags, &flags, sizeof(flags));
+
    b->cursor = nir_after_instr(&tex->instr);
 
    /* Only pick off slected components */
@@ -487,34 +529,34 @@ lower_image_txq(nir_builder *b, nir_intrinsic_instr *intrin,
 {
    b->cursor = nir_instr_remove(&intrin->instr);
 
-   /* TODO: We should only support 32-bit handles */
-   nir_def *img_h = nir_u2u32(b, intrin->src[0].ssa);
+   nir_def *img_h = intrin->src[0].ssa;
+
+   uint32_t texture_index = 0;
+   enum nak_nir_tex_ref_type ref_type = NAK_NIR_TEX_REF_TYPE_BINDLESS;
+   if (nak->sm >= 70 && tex_handle_as_bindless(img_h, &texture_index)) {
+      ref_type = NAK_NIR_TEX_REF_TYPE_CBUF;
+      img_h = NULL; // nir_imm_int(b, 0);
+   }
 
    nir_tex_instr *txq = nir_tex_instr_create(b->shader, 1);
    txq->sampler_dim = remap_sampler_dim(nir_intrinsic_image_dim(intrin));
    txq->is_array = nir_intrinsic_image_array(intrin);
    txq->dest_type = nir_type_int32;
 
+   nir_def *txq_src;
    nir_component_mask_t mask;
    switch (intrin->intrinsic) {
    case nir_intrinsic_bindless_image_size: {
-      nir_def *lod = intrin->src[1].ssa;
-
       txq->op = nir_texop_hdr_dim_nv;
-      txq->src[0] = (nir_tex_src) {
-         .src_type = nir_tex_src_backend1,
-         .src = nir_src_for_ssa(nir_vec2(b, img_h, lod)),
-      };
+      nir_def *lod = intrin->src[1].ssa;
+      txq_src = img_h != NULL ? nir_vec2(b, img_h, lod) : lod;
       mask = BITSET_MASK(intrin->def.num_components);
       break;
    }
 
    case nir_intrinsic_bindless_image_samples:
       txq->op = nir_texop_tex_type_nv;
-      txq->src[0] = (nir_tex_src) {
-         .src_type = nir_tex_src_backend1,
-         .src = nir_src_for_ssa(img_h),
-      };
+      txq_src = img_h != NULL ? img_h : nir_imm_int(b, 0);
       mask = BITSET_BIT(2);
       break;
 
@@ -522,6 +564,18 @@ lower_image_txq(nir_builder *b, nir_intrinsic_instr *intrin,
       unreachable("Invalid image query op");
    }
 
+   txq->src[0] = (nir_tex_src) {
+      .src_type = nir_tex_src_backend1,
+      .src = nir_src_for_ssa(txq_src),
+   };
+   txq->texture_index = texture_index;
+
+   struct nak_nir_tex_flags flags = {
+      .ref_type = ref_type,
+   };
+   STATIC_ASSERT(sizeof(flags) == sizeof(txq->backend_flags));
+   memcpy(&txq->backend_flags, &flags, sizeof(flags));
+
    nir_def_init(&txq->instr, &txq->def, 4, 32);
    nir_builder_instr_insert(b, &txq->instr);
 
diff --git a/src/nouveau/compiler/nak_private.h b/src/nouveau/compiler/nak_private.h
index 22b0a8f34ec3660cb155658bd0c25f1f97b16da0..59e043bc96f6d3dbad8a88e3cb1b8cbc46a7eea8 100644
--- a/src/nouveau/compiler/nak_private.h
+++ b/src/nouveau/compiler/nak_private.h
@@ -144,6 +144,23 @@ struct nak_io_addr_offset {
 struct nak_io_addr_offset
 nak_get_io_addr_offset(nir_def *addr, uint8_t imm_bits);
 
+enum nak_nir_tex_ref_type {
+   /** Indicates that this is a bindless texture */
+   NAK_NIR_TEX_REF_TYPE_BINDLESS,
+
+   /** Indicates that this is a bound texture
+    *
+    * The binding index provided in texture_index.
+    */
+   NAK_NIR_TEX_REF_TYPE_BOUND,
+
+   /** Indicates that this is a cbuf texture
+    *
+    * texture_index is (idx << 16) | offset.
+    */
+   NAK_NIR_TEX_REF_TYPE_CBUF,
+};
+
 enum nak_nir_lod_mode {
    NAK_NIR_LOD_MODE_AUTO = 0,
    NAK_NIR_LOD_MODE_ZERO,
@@ -159,13 +176,19 @@ enum nak_nir_offset_mode {
    NAK_NIR_OFFSET_MODE_PER_PX,
 };
 
+PRAGMA_DIAGNOSTIC_PUSH
+PRAGMA_DIAGNOSTIC_ERROR(-Wpadded)
 struct nak_nir_tex_flags {
+   enum nak_nir_tex_ref_type ref_type:2;
    enum nak_nir_lod_mode lod_mode:3;
    enum nak_nir_offset_mode offset_mode:2;
    bool has_z_cmpr:1;
    bool is_sparse:1;
-   uint32_t pad:25;
+   uint32_t pad:23;
 };
+PRAGMA_DIAGNOSTIC_POP
+static_assert(sizeof(struct nak_nir_tex_flags) == 4,
+              "nak_nir_tex_flags has no holes");
 
 bool nak_nir_lower_scan_reduce(nir_shader *shader);
 bool nak_nir_lower_tex(nir_shader *nir, const struct nak_compiler *nak);
diff --git a/src/nouveau/vulkan/nvk_nir_lower_descriptors.c b/src/nouveau/vulkan/nvk_nir_lower_descriptors.c
index fc1702d561cfe61f5910915ec1d8b2180a6fec67..7d8fd00a1010aad67e16c3bcb1647d10b49d77ac 100644
--- a/src/nouveau/vulkan/nvk_nir_lower_descriptors.c
+++ b/src/nouveau/vulkan/nvk_nir_lower_descriptors.c
@@ -56,6 +56,7 @@ struct lower_descriptors_ctx {
 
    bool use_bindless_cbuf;
    bool use_edb_buffer_views;
+   bool use_nak;
    bool clamp_desc_array_bounds;
    bool indirect_bind;
    nir_address_format ubo_addr_format;
@@ -1294,7 +1295,8 @@ lower_tex(nir_builder *b, nir_tex_instr *tex,
    }
 
    /* TODO: The nv50 back-end assumes it's 64-bit because of GL */
-   combined_handle = nir_u2u64(b, combined_handle);
+   if (!ctx->use_nak)
+      combined_handle = nir_u2u64(b, combined_handle);
 
    /* TODO: The nv50 back-end assumes it gets handles both places, even for
     * texelFetch.
@@ -1562,6 +1564,8 @@ nvk_nir_lower_descriptors(nir_shader *nir,
       .dev_info = &pdev->info,
       .use_bindless_cbuf = nvk_use_bindless_cbuf(&pdev->info),
       .use_edb_buffer_views = nvk_use_edb_buffer_views(pdev),
+      .use_nak = (nvk_nak_stages(&pdev->info) &
+                  mesa_to_vk_shader_stage(nir->info.stage)) != 0,
       .clamp_desc_array_bounds =
          rs->storage_buffers != VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT ||
          rs->uniform_buffers != VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT ||
